// Generated by CoffeeScript 1.8.0
var Ball, Game, Obstacle, Rect, Vector, game;

Vector = function(x, y) {
  this.x = x;
  this.y = y;
};

Vector.prototype.dot = function(v) {
  return this.x * v.x + this.y * v.y;
};

Vector.prototype.length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y);
};

Vector.prototype.normalize = function() {
  var s;
  s = 1 / this.length();
  this.x *= s;
  this.y *= s;
  return this;
};

Vector.prototype.multiply = function(s) {
  return new Vector(this.x * s, this.y * s);
};

Vector.prototype.addVector = function(v) {
  this.x += v.x;
  this.y += v.y;
  return this;
};

Rect = (function() {
  function Rect(context, color, x, y, width, height) {
    this.context = context;
    this.color = color;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  Rect.prototype.draw = function() {
    this.context.fillStyle = this.color;
    return this.context.fillRect(this.x, this.y, this.width, this.height);
  };

  return Rect;

})();

Obstacle = (function() {
  function Obstacle(context, color, xBegin, yBegin, xEnd, yEnd) {
    this.context = context;
    this.color = color;
    this.xBegin = xBegin;
    this.yBegin = yBegin;
    this.xEnd = xEnd;
    this.yEnd = yEnd;
    this.beginPoint = new Vector(xBegin, yBegin);
    this.endPoint = new Vector(xEnd, yEnd);
  }

  Obstacle.prototype.draw = function() {
    this.context.beginPath();
    this.context.moveTo(this.beginPoint.x, this.beginPoint.y);
    this.context.lineTo(this.endPoint.x, this.endPoint.y);
    this.context.lineWidth = 2;
    this.context.strokeStyle = this.color;
    return this.context.stroke();
  };

  return Obstacle;

})();

Ball = (function() {
  function Ball(context, color, x, y, radius, vx, vy) {
    this.context = context;
    this.color = color;
    this.radius = radius;
    this.mass = 1;
    this.point = new Vector(x, y);
    this.movVector = new Vector(vx, vy);
  }

  Ball.prototype.draw = function() {
    this.context.beginPath();
    this.context.arc(this.point.x, this.point.y, this.radius, 0, Math.PI * 2);
    this.context.stroke();
    this.context.fillStyle = this.color;
    return this.context.fill();
  };

  Ball.prototype.draw_arrow = function() {
    var angle, headLen;
    this.context.beginPath();
    headLen = 8;
    angle = Math.atan2(this.movVector.y, this.movVector.x);
    this.context.moveTo(this.point.x, this.point.y);
    this.context.lineTo(this.point.x + this.movVector.x, this.point.y + this.movVector.y);
    this.context.lineTo((this.point.x + this.movVector.x) - headLen * Math.cos(angle - Math.PI / 6), (this.point.y + this.movVector.y) - headLen * Math.sin(angle - Math.PI / 6));
    this.context.moveTo(this.point.x + this.movVector.x, this.point.y + this.movVector.y);
    this.context.lineTo((this.point.x + this.movVector.x) - headLen * Math.cos(angle + Math.PI / 6), (this.point.y + this.movVector.y) - headLen * Math.sin(angle + Math.PI / 6));
    this.context.strokeStyle = "#09A948";
    this.context.lineWidth = 2;
    this.context.stroke();
  };

  Ball.prototype.checkBallAndBorder = function(vx, vy, width, height) {
    var checkBorder, dv, dvx, dvy, getMin;
    checkBorder = function(x, vx, radius, border) {
      var dvx;
      dvx = Infinity;
      if (x + radius + vx >= border) {
        dvx = Math.abs(border - x - radius);
      }
      if (x - radius + vx <= 0) {
        dvx = Math.abs(x - radius);
      }
      return dvx;
    };
    getMin = function(x, y) {
      var min;
      min = y;
      if (x < y) {
        min = x;
      }
      return min;
    };
    dvx = checkBorder(this.point.x, this.movVector.x, this.radius, width);
    dvy = checkBorder(this.point.y, this.movVector.y, this.radius, height);
    dv = Math.abs(getMin(dvx / vx, dvy / vy));
    if (dv === Infinity) {
      console.log("maybe shit");
      return {
        yRatio: dvy / vy,
        xRatio: dvx / vx,
        minRatio: 1
      };
    } else {
      return {
        yRatio: dvy / vy,
        xRatio: dvx / vx,
        minRatio: dv
      };
    }
  };

  Ball.prototype.move = function(vx, vy, ratio) {
    this.point.x += vx * ratio;
    return this.point.y += vy * ratio;
  };

  Ball.prototype.checkInvertMove = function(xRatio, yRatio) {
    if (Math.abs(xRatio / this.movVector.x) <= 1) {
      this.movVector.x = -this.movVector.x;
    }
    if (Math.abs(yRatio / this.movVector.y) <= 1) {
      return this.movVector.y = -this.movVector.y;
    }
  };

  Ball.prototype.checkBallCollision = function(ball, width, height) {
    var coorDifference, distance, dotTemp, dt, mT, massSum, mtMul, radiusSum, v1, v2;
    coorDifference = new Vector(this.point.x - ball.point.x, this.point.y - ball.point.y);
    radiusSum = this.radius + ball.radius;
    distance = coorDifference.length();
    if (distance > radiusSum) {
      return;
    }
    massSum = this.mass + ball.mass;
    coorDifference.normalize();
    dt = new Vector(coorDifference.y, -coorDifference.x);
    mT = coorDifference.multiply(this.radius + ball.radius - distance);
    mtMul = mT.multiply(ball.mass / massSum);
    this.checkBorderMoveAndInvert(mtMul.x, mtMul.y, width, height);
    mtMul = mT.multiply(-this.mass / massSum);
    this.checkBorderMoveAndInvert(mtMul.x, mtMul.y, width, height);
    dotTemp = this.movVector.dot(coorDifference);
    v1 = coorDifference.multiply(dotTemp).length();
    v2 = coorDifference.multiply(ball.movVector.dot(coorDifference)).length();
    this.movVector = dt.multiply(this.movVector.dot(dt));
    this.movVector.addVector(coorDifference.multiply((ball.mass * (v2 - v1) + this.mass * v1 + ball.mass * v2) / massSum));
    ball.movVector = dt.multiply(ball.movVector.dot(dt));
    return ball.movVector.addVector(coorDifference.multiply((this.mass * (v1 - v2) + ball.mass * v2 + this.mass * v1) / massSum));
  };

  Ball.prototype.checkBorderMoveAndInvert = function(vx, vy, width, height) {
    var ratio;
    ratio = this.checkBallAndBorder(vx, vy, width, height);
    this.move(vx, vy, ratio.minRatio);
    return this.checkInvertMove(ratio.xRatio, ratio.yRatio);
  };

  return Ball;

})();

Game = (function() {
  var getPosition;

  function Game() {}

  Game.prototype.init = function() {
    this.canvas = document.getElementById("ballpool");
    this.canvas.width = 800;
    this.canvas.height = 600;
    this.context = this.canvas.getContext("2d");
    this.gameField = new Rect(this.context, "grey", 0, 0, 800, 600);
    this.gameField.draw();
    this.simpleBalls = [];
    return this.obstacles = [];
  };

  getPosition = function(element) {
    var xPosition, yPosition;
    xPosition = 0;
    yPosition = 0;
    while (element) {
      xPosition += element.offsetLeft - element.scrollLeft + element.clientLeft;
      yPosition += element.offsetTop - element.scrollTop + element.clientTop;
      element = element.offsetParent;
    }
    return {
      x: xPosition,
      y: yPosition
    };
  };

  Game.prototype.mouseDownBall = function(e) {
    var newBall, parentPosition, xPosition, yPosition;
    this.mouseDownFlag = 1;
    parentPosition = getPosition(e.currentTarget);
    xPosition = e.clientX - parentPosition.x;
    yPosition = e.clientY - parentPosition.y;
    this.mouseVectorBegin = new Vector(xPosition, yPosition);
    newBall = new Ball(game.context, "red", xPosition, yPosition, 10, 0, 0);
    return newBall.draw();
  };

  Game.prototype.mouseMoveBall = function(e) {
    var newBall, parentPosition, xPosition, yPosition;
    if (this.mouseDownFlag === 0 || this.mouseDownFlag === void 0) {
      return;
    }
    this.mouseDownFlag = 2;
    parentPosition = getPosition(e.currentTarget);
    xPosition = e.clientX - parentPosition.x;
    yPosition = e.clientY - parentPosition.y;
    game.context.clearRect(0, 0, 800, 600);
    game.draw();
    newBall = new Ball(game.context, "red", this.mouseVectorBegin.x, this.mouseVectorBegin.y, 10, xPosition - this.mouseVectorBegin.x, yPosition - this.mouseVectorBegin.y);
    newBall.draw();
    newBall.draw_arrow();
  };

  Game.prototype.mouseUpBall = function(e) {
    var newBall, parentPosition, xPosition, yPosition;
    if (this.mouseDownFlag < 2 || this.mouseDownFlag === void 0) {
      return;
    }
    this.mouseDownFlag = 0;
    parentPosition = getPosition(e.currentTarget);
    xPosition = e.clientX - parentPosition.x;
    yPosition = e.clientY - parentPosition.y;
    game.context.clearRect(0, 0, 800, 600);
    game.draw();
    newBall = new Ball(game.context, "red", this.mouseVectorBegin.x, this.mouseVectorBegin.y, 10, (xPosition - this.mouseVectorBegin.x) / 20, (yPosition - this.mouseVectorBegin.y) / 20);
    game.simpleBalls.push(newBall);
    newBall.draw();
  };

  Game.prototype.createBallButton = function() {
    var mousemove;
    this.canvas.removeEventListener("mousedown", this.getObstacleBeginPosition, false);
    this.canvas.removeEventListener("mousemove", mousemove = function() {
      this.mouseDownFlag = 1;
    }, false);
    this.canvas.removeEventListener("mouseup", this.getObstacleEndPosition, false);
    this.canvas.addEventListener("mousedown", this.mouseDownBall, false);
    this.canvas.addEventListener("mousemove", this.mouseMoveBall, false);
    return this.canvas.addEventListener("mouseup", this.mouseUpBall, false);
  };

  Game.prototype.getObstacleBeginPosition = function(e) {
    var parentPosition, xPosition, yPosition;
    this.mouseDownFlag = 1;
    parentPosition = getPosition(e.currentTarget);
    xPosition = e.clientX - parentPosition.x;
    yPosition = e.clientY - parentPosition.y;
    return this.mouseVectorBegin = new Vector(xPosition, yPosition);
  };

  Game.prototype.getObstacleEndPosition = function(e) {
    var coorDifference, obstacle, parentPosition, xPosition, yPosition;
    if (this.mouseDownFlag < 2 || this.mouseDownFlag === void 0) {
      return;
    }
    this.mouseDownFlag = 0;
    parentPosition = getPosition(e.currentTarget);
    xPosition = e.clientX - parentPosition.x;
    yPosition = e.clientY - parentPosition.y;
    this.mouseVectorEnd = new Vector(xPosition, yPosition);
    coorDifference = new Vector(this.mouseVectorEnd.x - this.mouseVectorBegin.x, this.mouseVectorEnd.y - this.mouseVectorBegin.y);
    if (coorDifference.length() < 15) {
      return;
    }
    obstacle = new Obstacle(game.context, "blue", this.mouseVectorBegin.x, this.mouseVectorBegin.y, this.mouseVectorEnd.x, this.mouseVectorEnd.y);
    game.obstacles.push(obstacle);
    obstacle.draw();
  };

  Game.prototype.createObstacleButton = function() {
    var mousemove;
    this.canvas.removeEventListener("mousedown", this.mouseDownBall, false);
    this.canvas.removeEventListener("mousemove", this.mouseMoveBall, false);
    this.canvas.removeEventListener("mouseup", this.mouseUpBall, false);
    this.mouseDownFlag = 0;
    this.canvas.addEventListener("mousedown", this.getObstacleBeginPosition, false);
    this.canvas.addEventListener("mousemove", mousemove = function() {
      if (this.mouseDownFlag === 1) {
        this.mouseDownFlag = 2;
      }
    }, false);
    return this.canvas.addEventListener("mouseup", this.getObstacleEndPosition, false);
  };

  Game.prototype.deleteFieldObjects = function() {
    var mousemove;
    this.canvas.removeEventListener("mousedown", this.mouseDownBall, false);
    this.canvas.removeEventListener("mousemove", this.mouseMoveBall, false);
    this.canvas.removeEventListener("mouseup", this.mouseUpBall, false);
    this.canvas.removeEventListener("mousedown", this.getObstacleBeginPosition, false);
    this.canvas.removeEventListener("mousemove", mousemove = function() {
      if (this.mouseDownFlag === 1) {
        this.mouseDownFlag = 2;
      }
    }, false);
    this.canvas.removeEventListener("mouseup", this.getObstacleEndPosition, false);
    clearTimeout(this.timer);
    this.simpleBalls = [];
    this.obstacles = [];
    return this.gameField.draw();
  };

  Game.prototype.draw = function() {
    var ball1, obstacle, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.gameField.draw();
    _ref = this.simpleBalls;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ball1 = _ref[_i];
      ball1.draw();
    }
    _ref1 = this.obstacles;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      obstacle = _ref1[_j];
      _results.push(obstacle.draw());
    }
    return _results;
  };

  Game.prototype.update = function() {
    this.context.clearRect(0, 0, 800, 600);
    this.updatePosition();
    return this.draw();
  };

  Game.prototype.animate = function() {
    var animation;
    animation = function(obj) {
      obj.update();
      return this.timer = setTimeout((function() {
        return animation(obj);
      }), 1);
    };
    return animation(this);
  };

  Game.prototype.updatePosition = function() {
    var ball, ball2, height, width, _i, _j, _len, _len1, _ref, _ref1, _results;
    width = game.gameField.width;
    height = game.gameField.height;
    _ref = this.simpleBalls;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ball = _ref[_i];
      _ref1 = this.simpleBalls;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ball2 = _ref1[_j];
        if (ball !== ball2) {
          ball.checkBallCollision(ball2, width, height);
        }
      }
      _results.push(ball.checkBorderMoveAndInvert(ball.movVector.x, ball.movVector.y, width, height));
    }
    return _results;
  };

  return Game;

})();

game = new Game();
